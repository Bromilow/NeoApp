Model Agency App — Full Technical & Product Specification

Purpose: build a creator (model/influencer) catalogue web app with two primary roles: Admin and Creator. The app will be developed in React (Vite) on Replit and deployed to AWS Amplify. Media (photos/videos) are stored in S3, authentication via Cognito (Amplify Auth), and the backend uses AWS AppSync (GraphQL) with DynamoDB for storage. The UI theme is cyberpunk purple — neon accents, dark backgrounds, futuristic typography.

Table of contents

Goals & MVP

User roles & permissions

High-level architecture

Data model (GraphQL schema + DynamoDB mapping)

API endpoints / GraphQL operations

Authentication & Authorization

File (media) uploads & processing

Frontend structure and routes

UI components & left navigation (per-role)

Top nav (public) pages

Design system & theme tokens (cyberpunk purple)

Messages (in-app messaging) details

Search & filtering for Admin -> Creators

Non-functional requirements: performance, security, accessibility

Test plan & acceptance criteria

Deployment steps (Replit -> Amplify) and CI/CD notes

Future/optional features

1) Goals & MVP

MVP should deliver:

Creator sign-up and profile creation with media gallery (photos + short videos)

Admin user management: view creators with filters

Dashboards (Creator: profile views & posts; Admin: total users & activity)

Simple in-app messaging (Creator <-> Admin)

Responsive UI with cyberpunk purple theme

Non-MVP (phase 2+): paid bookings, availability calendar, ratings/reviews, direct payments, advanced video transcoding.

2) User roles & permissions

Creator (authenticated)

Create / edit their profile (name, location, phone, description)

Upload photos/videos (S3)

View basic dashboard metrics (profile views, posts count)

View/send messages to Admin

Admin (authenticated)

View site-level dashboard (user count, activity, recent messages)

List/filter/search creators

Message creators

Moderate / deactivate creator profiles

Public (not-authenticated)

View About, Blog, Contact pages

Optionally view creators (decide public/private profiles)

Authorization model: Use Cognito groups or AppSync @auth rules to restrict operations. Admins belong to admin group; creators to creator group.

3) High-level architecture

Frontend: React (Vite) — hosted by AWS Amplify Hosting. Develop locally on Replit.

Auth: AWS Cognito (Amplify Auth)

API: AWS AppSync (GraphQL schema auto-generated by Amplify) backed by DynamoDB. Use GraphQL to simplify client-side data fetching.

Storage: S3 for media + CloudFront CDN (Amplify automatically sets this up for hosting + S3 assets)

File uploads: direct browser-to-S3 using pre-signed URLs (Amplify Storage)

Messaging: GraphQL-backed message records stored in DynamoDB, subscriptions via AppSync for near realtime.

Analytics/metrics: AWS Pinpoint or simple CloudWatch metrics; for MVP, store view counters in DynamoDB.

Diagram (conceptual):

React (browser) <---> AppSync (GraphQL) <---> DynamoDB
                      |--> S3 (media)
Cognito handles auth & groups; Amplify Hosting for static site.
4) Data model (core GraphQL types)
type User @model @auth(rules: [{allow: groups, groups: ["admin"], operations: [read, update, delete]}, {allow: owner, ownerField: "id", operations: [create, read, update]}]) {
  id: ID!
  email: AWSEmail!
  role: String! # 'creator' or 'admin'
  name: String
  location: String
  phone: String
  description: String
  profileViews: Int
  gallery: [Media]
  createdAt: AWSDateTime
}


type Media {
  id: ID!
  url: AWSURL!
  type: String! # 'image' | 'video'
  thumbnailUrl: AWSURL
  caption: String
  uploadedAt: AWSDateTime
}


type CreatorProfile @model @auth(rules: [{allow: groups, groups: ["admin"], operations: [read]}, {allow: owner, ownerField: "ownerId"}]){
  id: ID!
  ownerId: ID! # references User.id
  displayName: String
  bio: String
  attributes: ProfileAttributes
  gallery: [Media]
  createdAt: AWSDateTime
}


input ProfileAttributes {
  heightCm: Int
  hairColor: String
  eyeColor: String
  skinTone: String
  tags: [String]
}


type Message @model @auth(rules: [{allow: groups, groups: ["admin"], operations: [read, create, update]}, {allow: owner, ownerField: "senderId", operations: [create, read]}, {allow: owner, ownerField: "recipientId", operations: [read]}]){
  id: ID!
  senderId: ID!
  recipientId: ID!
  subject: String
  body: String
  createdAt: AWSDateTime
  read: Boolean
}

Note: @model is Amplify's directive. If you prefer REST endpoints, swap AppSync with API Gateway + Lambda.

5) API operations (example GraphQL queries/mutations)

createCreatorProfile, updateCreatorProfile, deleteCreatorProfile

listCreators(filter, limit, nextToken)

getCreatorById(id)

createMessage, listMessagesForUser(userId)

incrementProfileView(creatorId) — mutation to atomically increment counter (use Lambda or atomic update in DynamoDB/AppSync resolver)

searchCreators (filter by attributes like hairColor, tags)

6) Authentication & Authorization

Use Amplify Auth (Cognito User Pools): email/password registration.

During sign-up, if user selects Creator, add to creator group.

Admin accounts assigned to admin group (manually via the admin console or during onboarding via seed script).

Protect GraphQL ops with Cognito groups and owner-based rules.

7) Media uploads & processing

Use Amplify Storage (S3) to upload from client.

For videos, accept up to e.g. 100 MB for MVP. Validate duration/file size client-side.

On upload, create a Media record in DB with url pointing to S3 (private or public depending on access rules).

Generate thumbnails for video uploads using a Lambda triggered by S3 ObjectCreated event (optional for MVP; otherwise client provides thumbnail or use first-frame extraction later).

Use CloudFront to serve assets fast.

Enforce CORS on S3 and signed URLs for private content.

8) Frontend routes
/                      -> Public Landing (top nav: About, Blog, Contact)
/login                 -> Login
/signup                -> Sign-up
/dashboard             -> Dashboard (role-aware; redirects per-role)
/creator/profile       -> Creator profile edit
/creator/gallery       -> Creator gallery management
/messages              -> Messages (inbox)
/admin/creators        -> Admin creators list (filters)
/admin/creator/:id     -> Admin view creator
/blog                  -> Blog listing
/contact               -> Contact form
/about                 -> About page
9) UI components & left navigation

Left nav (shared style, items vary per-role)

Creator left nav

Dashboard

Profile

Gallery

Messages

Settings / Account

Admin left nav

Dashboard

Creators

Messages

Site Settings

Moderation

Shared components

Topbar (public) with About, Blog, Contact

Card (creator card), FilterPanel, Modal, DataTable, Avatar, UploadDropzone, MediaLightbox, Tag / Chips

10) Top nav (public) pages

About: short description of the agency and app

Blog: list of posts, single post page

Contact: simple contact form (name, email, message) -> sends email via SES or stores message in DB for Admin to view

11) Design system & theme tokens (Cyberpunk Purple)

Base tokens

Background (primary): #0b0620 (near-black violet)

Surface (cards): #1a1030

Accent purple: #8A2BE2 (or #9B59FF)

Neon cyan: #00FFF0

Neon magenta: #FF2D95

Highlight (glow): rgba(155,89,255,0.25)

Text primary: #E9E7FF (off-white)

Muted text: #B9B0D9

Typography

Headings: futuristic sans (e.g., Orbitron, Bebas Neue for headers)

Body: Inter or Roboto

Use letter-spacing on headings and subtle uppercase on nav.

UI rules

Use soft outer glow on focused elements (box-shadow using highlight color).

Neon accent borders on hover.

Dark translucent panels for side nav (backdrop blur optional).

Accessible contrast: ensure body text meets WCAG AA on dark surfaces.

Spacing & breakpoints

Mobile-first responsive layout. Left nav collapses to bottom drawer on mobile.

12) Messages (in-app messaging)

Messages stored in Message model. Simple threadless messages for MVP (one message record per message).

UI: inbox view grouped by conversation partner (Admin <> Creator). On receiving new message, AppSync subscription pushes UI update.

Notifications: show unread badges in left nav. Optionally send email notifications for new messages.

13) Search & filtering (Admin -> Creators)

Server-side filtering via GraphQL query args: filter: {attributes: {hairColor: {eq: "Blonde"}, tags: {contains: "mother"}}}

UI: filter panel with multi-select for tags, dropdowns for attributes, free-text search for name/location.

Pagination: cursor-based pagination via GraphQL nextToken (Amplify auto-implements).

14) Non-functional requirements

Performance: media served via CDN, lazy-load images, paginate lists (50 items/page default).

Security: HTTPS only, S3 policies, signed access to private media. Protect admin routes via Cognito group checks.

Scalability: DynamoDB scales; AppSync handles concurrent requests. Use proper indexing for filters (GSI on hairColor/tags if necessary).

Accessibility: keyboard navigable, ARIA labels, color contrast checks.

15) Test plan & acceptance criteria

Unit tests: components, utility functions. Use Jest + React Testing Library. Integration tests: E2E with Cypress (user signup, profile update, upload flow, messaging). Acceptance criteria examples:

Creator can sign up, create profile with at least 1 photo, and see it on their profile.

Admin can search creators by tag and open a creator profile.

Messages appear in inbox and Admin receives messages from Creator.

16) Deployment & CI/CD (Replit -> Amplify)

Development flow (suggested):

Create project in Replit (React Vite template). Keep repository on GitHub.

Configure Amplify Hosting: connect GitHub repo to Amplify, choose branch (main). Amplify will run build (e.g. npm run build) and host.

Use Amplify CLI or Amplify Console to add Auth (amplify add auth), API (amplify add api - GraphQL), and Storage (amplify add storage).

Push backend with amplify push (note: you can run Amplify CLI locally or configure CI with Amplify Console).